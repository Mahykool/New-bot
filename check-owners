// check-owners.js
// Verifica que los owners de config.js estÃ©n sincronizados en lib/user-roles.json
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

// Ajusta si tus rutas son distintas
const ROOT = process.cwd()
const CONFIG_PATH = path.join(ROOT, 'config.js')
const USER_ROLES_PATH = path.join(ROOT, 'lib', 'user-roles.json')

// Helper: intenta cargar config.js de forma segura
function loadConfig() {
  try {
    // Import dinÃ¡mico para respetar cambios recientes
    const cfg = await import(pathToFileURL(CONFIG_PATH).href + `?update=${Date.now()}`)
    return cfg.default || cfg
  } catch (e) {
    // Fallback: intentar leer como JSON-like (si config.js exporta objeto simple)
    try {
      const raw = fs.readFileSync(CONFIG_PATH, 'utf8')
      // Intento simple: buscar owner = [...] con regex (no perfecto, pero Ãºtil)
      const m = raw.match(/owner\s*[:=]\s*(\[[\s\S]*?\])/m)
      if (m && m[1]) {
        // eslint-disable-next-line no-eval
        const owners = eval(m[1])
        return { owner: owners }
      }
    } catch {}
    throw new Error('No se pudo cargar config.js')
  }
}

// Normaliza JID similar a lib/lib-roles.js
function normalizeJid(jid) {
  if (!jid) return jid
  jid = String(jid).trim()
  const base = jid.split(':')[0].split('/')[0]
  if (base.includes('@')) return base
  return `${base}@s.whatsapp.net`
}

function filePermsInfo(filePath) {
  try {
    const stat = fs.statSync(filePath)
    const mode = stat.mode & 0o777
    return { exists: true, mode: mode.toString(8), size: stat.size, mtime: stat.mtime.toISOString() }
  } catch (e) {
    return { exists: false }
  }
}

async function main() {
  console.log('ðŸ”Ž Verificando owners en lib/user-roles.json\n')

  // 1) Cargar config.js y extraer owners
  let config
  try {
    // preferir import dinÃ¡mico si es mÃ³dulo ESM
    const { default: cfgDefault } = await import(pathToFileURL(CONFIG_PATH).href + `?update=${Date.now()}`)
    config = cfgDefault || {}
  } catch (e) {
    // fallback: intentar require-like parse
    try {
      const raw = fs.readFileSync(CONFIG_PATH, 'utf8')
      const m = raw.match(/owner\s*[:=]\s*(\[[\s\S]*?\])/m)
      if (m && m[1]) {
        // eslint-disable-next-line no-eval
        config = { owner: eval(m[1]) }
      } else {
        throw e
      }
    } catch (err) {
      console.error('âŒ Error cargando config.js:', err.message || err)
      process.exit(1)
    }
  }

  const ownersRaw = Array.isArray(config.owner) ? config.owner.flat() : (config.owner ? [config.owner] : [])
  const owners = ownersRaw
    .map(o => {
      if (!o) return null
      if (Array.isArray(o)) return o[0]
      if (typeof o === 'object' && o.jid) return o.jid
      return String(o)
    })
    .filter(Boolean)
    .map(normalizeJid)

  if (!owners.length) {
    console.warn('âš ï¸ No se encontraron owners en config.js')
  } else {
    console.log(`Owners detectados (${owners.length}):`)
    owners.forEach(o => console.log(' -', o))
  }

  // 2) Cargar lib/user-roles.json
  let userRoles = {}
  try {
    if (!fs.existsSync(USER_ROLES_PATH)) {
      console.warn(`âš ï¸ Archivo no encontrado: ${USER_ROLES_PATH}`)
    } else {
      const raw = fs.readFileSync(USER_ROLES_PATH, 'utf8') || '{}'
      userRoles = JSON.parse(raw)
    }
  } catch (e) {
    console.error('âŒ Error leyendo user-roles.json:', e.message || e)
    process.exit(1)
  }

  // 3) Comprobar cada owner
  console.log('\nðŸ” VerificaciÃ³n por owner:')
  const missing = []
  const ok = []
  for (const o of owners) {
    const roles = userRoles[o]
    if (!roles) {
      missing.push(o)
      console.log(` âœ– FALTA: ${o} â€” no estÃ¡ en user-roles.json`)
    } else if (!Array.isArray(roles)) {
      console.log(` âš  FORMATO INVÃLIDO: ${o} â€” valor no es array (valor: ${JSON.stringify(roles)})`)
    } else if (!roles.map(r => String(r).toLowerCase()).includes('creador')) {
      console.log(` âš  SIN 'creador': ${o} â€” roles actuales: ${JSON.stringify(roles)}`)
    } else {
      ok.push(o)
      console.log(` âœ” OK: ${o} â€” contiene 'creador'`)
    }
  }

  // 4) Mostrar info del archivo y permisos
  console.log('\nðŸ“ InformaciÃ³n del archivo user-roles.json:')
  const info = filePermsInfo(USER_ROLES_PATH)
  if (!info.exists) {
    console.log(` - Ruta: ${USER_ROLES_PATH} (no existe)`)
  } else {
    console.log(` - Ruta: ${USER_ROLES_PATH}`)
    console.log(` - TamaÃ±o: ${info.size} bytes`)
    console.log(` - Permisos (octal): ${info.mode}`)
    console.log(` - Ãšltima modificaciÃ³n: ${info.mtime}`)
  }

  // 5) Resumen
  console.log('\nðŸ“Š Resumen:')
  console.log(` - Owners detectados: ${owners.length}`)
  console.log(` - Owners OK (tienen 'creador'): ${ok.length}`)
  console.log(` - Owners faltantes: ${missing.length}`)
  if (missing.length) {
    console.log('\nRecomendaciÃ³n: si faltan owners, ejecuta el script de sincronizaciÃ³n o aÃ±ade manualmente las entradas en lib/user-roles.json con el formato:')
    console.log(`  { "${missing[0]}": ["creador"] }`)
  }

  process.exit(0)
}

// Utilidad para convertir ruta a file URL (usada en import dinÃ¡mico)
function pathToFileURL(p) {
  const u = new URL('file://' + path.resolve(p))
  return u
}

main().catch(e => {
  console.error('Error inesperado:', e)
  process.exit(1)
})
